# #Problem 1 (done?)
# count=0
# value=0
# print (count)
# print (value)
# while value < 1000:
#     if value %3 or value%5 ==0:
#         count= count+1
#         value= value+1 
#     else: 
#         value= value+1
# if value == 1000:
#     print(count)

# def fibSeq(length):
#     firstN = 0
#     secondN = 1
#     count = 0
#     fiblist= []
#     while count < length:
#        print(firstN)
#        temp = firstN + secondN
#        firstN = secondN
#        secondN = temp
#        count += 1
#     return fiblist

# print (fibSeq(7))

# def evenFib(number):
#     count= 0
#     value= 1
#     result=[]
#     while count < number:
#         if count % 2 !=0:         
#             result += [count]
#     return result
# print (sum(evenFib(42)))



# #Problem 2 (not done)
# totalnumber = 41
# x=0
# y=1
# count = 0

# while count < totalnumber:
#     fiblist=[]
#     fib = x + y
#     fiblist.append(fib)
#     x = fiblist[-1]
#     y = fib
#     count += 1
# print(fiblist)
# #figure out how to use the while loop to add numbers instead of just having a single item in that list 


#############
##problem 3##
#############
# number=600851475143
# #specific number when trying to find the prime number
# primeFactor = 1
# #essentially a counter that identifies the largest prime factor of the number 
# counter = 2
# #this will be used to find the largest prime factor 

# while counter <= number:
#     #keeps going until all numbers have been gone through
#     if number %counter == 0:
#         #checks to see if the number is a prime factor of 'number'
#         primeFactor = counter
#         #sets prime factor equal to the counter is  to update the largest prime factor 
#         number /= primeFactor
#         #helpful notation to make number equal to number divided by the value of counter in this
#         #divides the code by the primeFactor to shorten the amount of iterations needed 
#     else:
#         counter =counter+ 1
#         #when number is not prime increase counter 

# print (primeFactor)




# #############
# ##problem 4##
# #############
# largestPalendrome= 0
# #keeps track of the largest palendrome saved
# for x in range (100,999):
#     for y in range (100,999):
#         #the problem requires two variables that are three digits, which is why both x and y are present
#         palendrome = x * y
#         if str(palendrome) == str(palendrome)[::-1]:
#             #checks if x*y is a palendrome 
#             if palendrome > largestPalendrome:
#                 #checks to see if the palendrome is the largest one yet
#                 largestPalendrome = palendrome
                
# print (largestPalendrome)


#############
##problem 5##
#############



#helper function checks if a given number is divided between the range 1-20
def isDivisble(number):
    #goes through iterations 1-20
    for i in range(1,21):
        #when the number is divisble by the given number 
        if number % i == 0:
            pass
        #sets up a given statement where the output is either true or false if the expression is divisble 
        else:
            return False
    return True
#goes through all possible numbers for this algorithm 
counter = 1
#determies when a divisble number is not found
while isDivisble(counter) == False:
    #upates counter 
    counter += 1
#prints the smallest number that is evenly divisble by all the numbers between 1-20 (will take a while to compute)
print (counter)

   
    

# # if __name__ == '__main__':
# #    num = 1
#    while not div_check(num):
#        print (num)
#        num += 1
# #    print (num)

# #############
# ##problem 6##
# #############
# numbers = []
# numbers.extend(range(1,101))
# #creates a list with values 1-100
# squarednumbers= [number ** 2 for number in numbers]
# #squares the numbers in the list
# SquaredSum = sum(squarednumbers) 
# #adds those numbers together
# SumSquared = sum(numbers) **2
# #adds numbers 1-100 together and then squares it 
# final = SumSquared - SquaredSum
# #finds the difference 
# print(final)
